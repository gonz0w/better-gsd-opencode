---
phase: 50-integration-agent-context-dead-end-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/commands/trajectory.js
  - src/lib/constants.js
  - src/router.js
  - bin/gsd-tools.cjs
autonomous: true
requirements: [INTEG-01, INTEG-03, INTEG-04]

must_haves:
  truths:
    - "trajectory dead-ends command queries journal for pivot entries and surfaces warnings about failed approaches"
    - "Dead-end context is formatted as 'what NOT to do' warnings with reasons from pivot entries"
    - "All trajectory commands validate --scope to only accept task, plan, or phase"
    - "Invalid scope values produce a clear error message listing valid options"
  artifacts:
    - path: "src/commands/trajectory.js"
      provides: "queryDeadEnds helper, cmdTrajectoryDeadEnds command, formatDeadEndContext formatter"
      exports: ["cmdTrajectoryDeadEnds"]
    - path: "src/lib/constants.js"
      provides: "VALID_TRAJECTORY_SCOPES constant and dead-ends help text"
      contains: "VALID_TRAJECTORY_SCOPES"
    - path: "src/router.js"
      provides: "dead-ends subcommand routing"
      contains: "case 'dead-ends'"
  key_links:
    - from: "src/commands/trajectory.js"
      to: ".planning/memory/trajectory.json"
      via: "fs.readFileSync in queryDeadEnds"
      pattern: "trajectory\\.json"
    - from: "src/router.js"
      to: "src/commands/trajectory.js"
      via: "lazyTrajectory().cmdTrajectoryDeadEnds"
      pattern: "cmdTrajectoryDeadEnds"
---

<objective>
Create dead-end detection library and scope validation for trajectory commands.

Purpose: Enable agents to query the trajectory journal for failed approaches before starting new work, preventing re-exploration of known dead ends. Also standardize scope parameter validation across all trajectory commands.
Output: `trajectory dead-ends` command, `queryDeadEnds` helper for init integration, validated scope parameter.
</objective>

<execution_context>
@/home/cam/.config/oc/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/oc/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/INTENT.md
@src/commands/trajectory.js
@src/lib/constants.js
@src/router.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dead-end detection helpers and command</name>
  <files>src/commands/trajectory.js, src/lib/constants.js</files>
  <action>
In src/lib/constants.js:
- Add `const VALID_TRAJECTORY_SCOPES = ['task', 'plan', 'phase'];` near the top constants section.
- Export it from the module.
- Add help text for `trajectory dead-ends` to COMMAND_HELP: `'trajectory dead-ends': 'Query journal for failed approaches.\n  Usage: trajectory dead-ends [--scope <scope>] [--name <name>] [--limit <N>] [--token-cap <N>]\n  Shows pivot/abandon entries as "what NOT to do" context.'`

In src/commands/trajectory.js:
- Import VALID_TRAJECTORY_SCOPES from constants.
- Add a `validateScope(scope)` helper at top of file that checks scope is in VALID_TRAJECTORY_SCOPES and calls `error()` if not: `error('Invalid scope: "' + scope + '". Valid scopes: ' + VALID_TRAJECTORY_SCOPES.join(', '))`.
- Add `validateScope(scope)` call after scope parsing in each existing command: cmdTrajectoryCheckpoint, cmdTrajectoryPivot, cmdTrajectoryCompare, cmdTrajectoryChoose. (cmdTrajectoryList uses scopeFilter which can be null, so validate only when non-null.)
- Create `queryDeadEnds(cwd, { scope, name, limit })` function:
  - Read trajectory.json from `.planning/memory/trajectory.json`
  - Filter entries where `category === 'pivot'` (these are abandoned approaches)
  - If scope provided, filter by `entry.scope === scope`
  - If name provided, filter by `entry.checkpoint_name === name`
  - Sort by timestamp descending (most recent first)
  - Apply limit (default 10)
  - Return array of `{ checkpoint_name, scope, reason, attempt, timestamp, branch }` objects
- Create `formatDeadEndContext(deadEnds, tokenCap)` function:
  - Takes array from queryDeadEnds and a token cap (default 500)
  - Formats each as: `"- [scope/name] attempt-N: {reason}"` (one line per dead end)
  - Estimates tokens as chars/4
  - Truncates output at tokenCap tokens, appending `"... and N more dead ends"` if truncated
  - Returns string (empty string if no dead ends)
- Create `cmdTrajectoryDeadEnds(cwd, args, raw)` function:
  - Parse args: `--scope`, `--name`, `--limit`, `--token-cap`
  - Call queryDeadEnds with parsed options
  - JSON output: `{ dead_ends: [...], count, scope_filter, name_filter, context: formatDeadEndContext(results) }`
  - TTY output: banner "DEAD ENDS", table with Name/Scope/Attempt/Reason columns, summary line with count, action hint
  - If no dead ends found: `{ dead_ends: [], count: 0, context: "" }`
- Export cmdTrajectoryDeadEnds and queryDeadEnds from module.exports (queryDeadEnds is needed by init.js in Plan 02).

Follow existing trajectory.js patterns:
- Use `const { output, error, debugLog } = require('../lib/output')` (already imported)
- Use `path.join(cwd, '.planning', 'memory', 'trajectory.json')` for journal path
- Use try/catch with debugLog for missing journal file
- Use banner(), formatTable(), summaryLine(), actionHint() from format.js for TTY output (import pattern matches existing formatCompareResult)
  </action>
  <verify>npm run build && node bin/gsd-tools.cjs trajectory dead-ends 2>&1 | head -5 (should output JSON with empty dead_ends since no pivots exist in test context)</verify>
  <done>queryDeadEnds returns pivot entries from journal, formatDeadEndContext produces token-capped "what NOT to do" strings, cmdTrajectoryDeadEnds command works in both JSON and TTY mode, all existing trajectory commands reject invalid scope values</done>
</task>

<task type="auto">
  <name>Task 2: Wire router and rebuild bundle</name>
  <files>src/router.js, bin/gsd-tools.cjs</files>
  <action>
In src/router.js:
- Add `case 'dead-ends':` to the trajectory switch block (after 'choose' case): `lazyTrajectory().cmdTrajectoryDeadEnds(cwd, args.slice(2), raw); break;`
- Update the default error message to include 'dead-ends' in the available subcommands list: `'Available: checkpoint, list, pivot, compare, choose, dead-ends'`

Build:
- Run `npm run build` to rebuild bin/gsd-tools.cjs
- Verify: `node bin/gsd-tools.cjs trajectory dead-ends` returns valid JSON
- Verify: `node bin/gsd-tools.cjs trajectory dead-ends --scope invalid` returns scope validation error
- Verify: `node bin/gsd-tools.cjs trajectory --help` includes dead-ends in help text
  </action>
  <verify>npm run build && node bin/gsd-tools.cjs trajectory dead-ends 2>&1 && npm test 2>&1 | tail -5</verify>
  <done>trajectory dead-ends subcommand is routable, help text lists it, build passes within 1050KB budget, all existing tests pass</done>
</task>

</tasks>

<verification>
- `node bin/gsd-tools.cjs trajectory dead-ends` returns `{ dead_ends: [], count: 0, context: "" }`
- `node bin/gsd-tools.cjs trajectory dead-ends --scope invalid` produces error about valid scopes
- `node bin/gsd-tools.cjs trajectory checkpoint test --scope banana` produces scope validation error
- All existing trajectory tests pass (checkpoint, list, pivot, compare, choose)
- Bundle size under 1050KB
</verification>

<success_criteria>
Dead-end detection library exists and is callable both as a CLI command and as a JS function for init integration. Scope validation prevents invalid scope values across all trajectory commands. All existing tests continue to pass.
</success_criteria>

<output>
After completion, create `.planning/phases/50-integration-agent-context-dead-end-detection/50-01-SUMMARY.md`
</output>
