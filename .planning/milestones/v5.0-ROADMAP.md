# Milestone v5.0: Codebase Intelligence

**Status:** SHIPPED 2026-02-26
**Phases:** 23-29
**Total Plans:** 14

## Overview

Give GSD codebase awareness — conventions, dependencies, lifecycle, and task-scoped context — so AI agents understand project structure before making changes.

## Phases

### Phase 23: Infrastructure & Storage

**Goal**: Build the foundation — codebase-intel.json storage, git-based staleness detection, incremental analysis, auto-trigger on init commands
**Depends on**: Nothing (foundation phase)
**Requirements**: INFRA-01, INFRA-02, INFRA-03, INFRA-04
**Plans**: 2 plans

Plans:
- [x] 23-01: Core intel engine + CLI commands — codebase-intel.json storage, 59-extension language detection, git-based staleness, analyze/status commands
- [x] 23-02: Init integration + test coverage — autoTriggerCodebaseIntel wired into 4 init commands, formatCodebaseSummary, 14 tests

**Details:**
- codebase-intel.json with git hash watermarks for freshness validation
- 59-extension language detection with line counting
- Git-diff-based staleness as primary strategy with mtime fallback
- Auto-trigger on init commands when stale (follows env.js pattern)

### Phase 24: Convention Extraction

**Goal**: Auto-detect naming patterns, file organization rules, and framework-specific conventions with confidence scoring
**Depends on**: Phase 23 (storage infrastructure)
**Requirements**: CONV-01, CONV-02, CONV-03, CONV-04, CONV-05
**Plans**: 2 plans

Plans:
- [x] 24-01: Convention extraction engine — naming pattern detection (5 patterns), file organization analysis, confidence scoring, `codebase conventions` command
- [x] 24-02: Framework detection + rules generation — extensible FRAMEWORK_DETECTORS registry, Elixir/Phoenix detector, `codebase rules` with cap at 15, 6 tests

**Details:**
- Naming pattern detection: camelCase, snake_case, PascalCase, kebab-case, UPPER_CASE
- File organization rules (directory structure, placement patterns)
- Framework-specific macros (Elixir: Phoenix routes, Ecto schemas, plugs)
- Confidence scoring per convention (percentage of files following pattern)

### Phase 25: Dependency Graph

**Goal**: Build module dependency graph from import/require/use statements with impact analysis and cycle detection
**Depends on**: Phase 23 (storage infrastructure)
**Requirements**: DEPS-01, DEPS-02, DEPS-03, DEPS-04, DEPS-05
**Plans**: 2 plans

Plans:
- [x] 25-01: Core dependency graph engine — 6-language import parsers (JS, TS, Python, Go, Elixir, Rust), forward/reverse adjacency lists, `codebase deps` command
- [x] 25-02: Impact analysis + cycle detection — Tarjan's SCC algorithm, BFS transitive dependents, `codebase impact` command, 14 tests

**Details:**
- Regex-based import parsing over AST — zero dependencies, 85-90% accuracy
- Adjacency-list representation with forward and reverse edges
- Tarjan's SCC for cycle detection, BFS with maxDepth=10 for impact analysis

### Phase 26: Init Integration & Context Summary

**Goal**: Wire codebase analysis into init commands with compact summary injection and auto-trigger
**Depends on**: Phase 24 (conventions), Phase 25 (dependency graph)
**Requirements**: CTXI-01, INFRA-04
**Plans**: 2 plans

Plans:
- [x] 26-01: Three-field context summary (stats, conventions, dependencies) with confidence scores + hybrid staleness detection
- [x] 26-02: Non-blocking background analysis with lock file, --refresh flag, 8 tests

**Details:**
- Three-field structured context (stats, conventions, dependencies) with per-field confidence scores
- Non-blocking background analysis by default with --refresh for sync override
- Lock file with 5-min expiry to prevent concurrent analysis

### Phase 27: Task-Scoped Context

**Goal**: On-demand per-file architectural context for executor agents with heuristic relevance scoring
**Depends on**: Phase 24 (conventions), Phase 25 (dependency graph)
**Requirements**: CTXI-02, CTXI-03, CTXI-04
**Plans**: 2 plans

Plans:
- [x] 27-01: Core codebase context command with per-file assembly (imports, dependents, conventions, risk level)
- [x] 27-02: Heuristic relevance scoring + 5K token budget enforcement + 14 tests

**Details:**
- Heuristic relevance scoring: graph distance 50%, plan scope 30%, git recency 20%
- 5K token budget with 4-level graceful degradation
- Per-file context: imports, dependents, conventions, risk level

### Phase 28: Lifecycle Analysis

**Goal**: Detect execution order relationships — seeds after migrations, config at boot, framework-specific initialization patterns
**Depends on**: Phase 23 (storage infrastructure)
**Requirements**: LIFE-01, LIFE-02, LIFE-03
**Plans**: 2 plans

Plans:
- [x] 28-01: Core lifecycle library — LIFECYCLE_DETECTORS registry, generic migration + Elixir/Phoenix detectors, DAG builder, Kahn's topological sort
- [x] 28-02: Lifecycle CLI integration — `codebase lifecycle` command, intel caching, preservation in autoTrigger and analyze, 11 tests

**Details:**
- Framework detector registry as simple array of `{ name, detect, extractPatterns }` objects
- Generic migration detector + Elixir/Phoenix-specific detector
- DAG builder with Kahn's topological sort for execution ordering

### Phase 29: Workflow Integration

**Goal**: Wire codebase intelligence into execute-phase, plan-phase, and map-codebase workflows
**Depends on**: Phase 26 (init integration), Phase 27 (task-scoped context)
**Requirements**: WKFL-01, WKFL-02, WKFL-03
**Plans**: 2 plans

Plans:
- [x] 29-01: Execute-phase context injection + pre-flight convention check
- [x] 29-02: Graph-first codebase-impact command upgrade with grep fallback, 4 tests

**Details:**
- Convention check is advisory-only with >80% confidence threshold
- codebase-impact uses cached dependency graph when available, grep fallback otherwise

---

## Milestone Summary

**Key Decisions:**
- Git-diff-based staleness as primary strategy with mtime fallback for non-git repos
- Regex-based import parsing over AST — zero dependencies, 85-90% accuracy
- Framework detector registry as extensible array pattern
- Tarjan's SCC for cycle detection, BFS with maxDepth=10 for impact analysis
- Three-field structured context with per-field confidence scores
- Heuristic relevance scoring: graph distance 50%, plan scope 30%, git recency 20%
- 5K token budget with 4-level graceful degradation
- Convention check is advisory-only

**Issues Resolved:**
- Fixed camelCase regex matching single-word names (false positive inflation)
- Fixed autoTriggerCodebaseIntel overwriting conventions/dependencies on re-analysis
- Fixed getTransitiveDependents return format mapping in codebase-impact

**Issues Deferred:**
- 2 pre-existing test failures (bundle size budget, batch grep) — fixed in v6.0

**Technical Debt Incurred:**
- Bundle at 672KB / 700KB budget

---

_For current project status, see .planning/ROADMAP.md_
